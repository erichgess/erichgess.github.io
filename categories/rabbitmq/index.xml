<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on Elegant Architecture</title><link>http://example.org/categories/rabbitmq/</link><description>Recent content in RabbitMQ on Elegant Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 Mar 2014 22:08:19 -0800</lastBuildDate><atom:link href="http://example.org/categories/rabbitmq/index.xml" rel="self" type="application/rss+xml"/><item><title>RabbitMQ and F# - Part 6</title><link>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-6/</link><pubDate>Sat, 08 Mar 2014 22:08:19 -0800</pubDate><guid>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-6/</guid><description>A final round of polish. Now that I have the layout and flow for using my RabbitMQ library defined, it&amp;rsquo;s time to go through and do a bit of clean up on my names. There&amp;rsquo;s a lot I can do to make it so that code you write with this library becomes as readable and literate as possible.
Here&amp;rsquo;s the code you write to do the initial setup:
let connection = openConnection &amp;#34;localhost&amp;#34; let myChannel = openChannel connection If I just look at this, I have to ask: open connection to what?</description></item><item><title>RabbitMQ and F# - Part 5</title><link>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-5/</link><pubDate>Sat, 08 Mar 2014 22:00:00 -0800</pubDate><guid>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-5/</guid><description>Alright, I now have a simple usable RabbitMQ client library which fits comfortably with F#. However, there&amp;rsquo;s still some inconsistency in the design which I want to polish out:
To create a consumer on a queue, you call: createQueueConsumer myChannel &amp;#34;myQueue&amp;#34; To create a read function for a queue, you call: let (readFrom,_) = createQueueFuntions myChannel let readFromMyQueue = readFrom &amp;#34;myQueue&amp;#34; To create a write function for a queue, you call: let (_,writeTo) = createQueueFuntions myChannel let writeToMyQueue = writeTo &amp;#34;myQueue&amp;#34; Why have a function which manages both the read AND the writes for a channel?</description></item><item><title>RabbitMQ and F# - Part 4</title><link>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-4/</link><pubDate>Sat, 08 Mar 2014 21:55:44 -0800</pubDate><guid>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-4/</guid><description>In my previous post, I made my RabbitMQ client library a bit more functional by removing the Queue record type and replacing it with higher order functions. These higher order functions are used for creating functions for reading/writing queues. If you want to use &amp;ldquo;MyQueue&amp;rdquo; for writing, you use the &amp;ldquo;writeTo&amp;rdquo; higher order function to create a function for writing to &amp;ldquo;MyQueue&amp;rdquo;. It&amp;rsquo;s sounds more complex than it really is.</description></item><item><title>RabbitMQ and F# - Part 3</title><link>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-3/</link><pubDate>Sat, 08 Mar 2014 21:38:01 -0800</pubDate><guid>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-3/</guid><description>I now have a functioning RabbitMQ Library! Though, there is a lot more to be done to make it satisfactory.
There are two problems:
Missing the Queue Consumer functionality. This makes it a lot easier to deal with RabbitMQ so I definitely want to get this in. I&amp;rsquo;m not happy with using the record type to capture the Read and Publish functions for a queue. After all, how often are you going to be writing to and reading from a specific queue in the same process?</description></item><item><title>RabbitMQ and F# - Part 2</title><link>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-2/</link><pubDate>Sat, 08 Mar 2014 21:15:36 -0800</pubDate><guid>http://example.org/posts/2014-03-08-rabbitmq-and-f-number-part-2/</guid><description>Notes about RabbitMQ: - You should have one connection per application and one channel per thread (http://stackoverflow.com/a/10501593)
I was able to build and run my sender and receiver, both using my client.
However, something odd happened. The receiver was only printing out every other message which the Sender sent.
Here&amp;rsquo;s the secret of what&amp;rsquo;s happening:
OH SNAP! There are two consumers on the queue and RabbitMQ is splitting the messages evenly between the two consumers.</description></item><item><title>Building a RabbitMQ Library in F#</title><link>http://example.org/posts/2014-03-06-building-a-rabbitmq-library-in-f-number/</link><pubDate>Thu, 06 Mar 2014 07:44:30 -0800</pubDate><guid>http://example.org/posts/2014-03-06-building-a-rabbitmq-library-in-f-number/</guid><description>I&amp;rsquo;ve been doing a lot of experimenting with F# and distributed computing via messaging. As evidenced by my previous, I&amp;rsquo;m using RabbitMQ as my messaging platform, for a couple of reasons: it&amp;rsquo;s easy to use, it&amp;rsquo;s free and open source, and I might decide to switch to RabbitMQ at work. I&amp;rsquo;ve been having a lot of fun experimenting with RabbitMQ and F#. However, I spend a lot of my time just writing and copy/pasting the boilerplate code needed to configure the RabbitMQ client libraries, add the fact that the .</description></item><item><title>Using RabbitMQ with F#</title><link>http://example.org/posts/2014-03-04-using-rabbitmq-with-f-number/</link><pubDate>Tue, 04 Mar 2014 19:56:20 -0800</pubDate><guid>http://example.org/posts/2014-03-04-using-rabbitmq-with-f-number/</guid><description>Over the last few years, one of the topics on which I have done much of my work has been distributed computing using message queues. Recently, I&amp;rsquo;ve been playing around with RabbitMQ, not for any reason other than that I wanted a simple, easy to setup, and easy to use messaging framework, which I could use for little experiments at home.
I&amp;rsquo;m not going to talk much about using RabbitMQ. What I am going to talk about is one of the many ways in which F# makes programming just an absolute blast.</description></item></channel></rss>