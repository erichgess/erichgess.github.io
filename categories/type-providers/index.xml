<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Type Providers on Elegant Architecture</title><link>http://example.org/categories/type-providers/</link><description>Recent content in Type Providers on Elegant Architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Apr 2014 22:09:16 -0700</lastBuildDate><atom:link href="http://example.org/categories/type-providers/index.xml" rel="self" type="application/rss+xml"/><item><title>Type Providers Tutorial Part 4 - Base Types</title><link>http://example.org/posts/2014-04-16-type-providers-tutorial-part-4/</link><pubDate>Wed, 16 Apr 2014 22:09:16 -0700</pubDate><guid>http://example.org/posts/2014-04-16-type-providers-tutorial-part-4/</guid><description>In Part 3 of this Tutorial, I talked a little about erased types and how the types we generate are actually built on top of a obj. Previously, I just used a plan obj type and cast an integer to and from the obj types.
InvokeCode= (fun args -&amp;gt; &amp;lt;@@ 0 :&amp;gt; obj @@&amp;gt;)) Using just the basic obj works well enough for a very simple generated type (like the simple integer from part 3).</description></item><item><title>Type Providers - Tutorial Part 3 - Instantiables</title><link>http://example.org/posts/2014-04-05-type-providers-tutorial-part-3-instantiables/</link><pubDate>Sat, 05 Apr 2014 13:42:52 -0700</pubDate><guid>http://example.org/posts/2014-04-05-type-providers-tutorial-part-3-instantiables/</guid><description>In the last tutorial, we built a simple type named Hello which had some static members. In this tutorial, we&amp;rsquo;ll expand our Hello type to include a constructor, an instance property, and an instance method. Adding these will allow us to create instances of Hello using the new operator:
let x = new Hello() We&amp;rsquo;ll also make Hello store some data, that means our type providers will be one step closer to awesome.</description></item><item><title>Type Providers - Tutorial Part 2</title><link>http://example.org/posts/2014-04-04-type-providers-tutorial-part-2/</link><pubDate>Fri, 04 Apr 2014 17:51:36 -0700</pubDate><guid>http://example.org/posts/2014-04-04-type-providers-tutorial-part-2/</guid><description>In Part 1 of this series, I briefly explained what a Type Provider was and some of the main concepts which you would need to know. In Part 2, I am going to build a very simple Type Provider. The purpose of Part 2 is to cover the basics of developing Type Providers, how to test them with F# Interactive, and the support tools which make developing Type Providers easy.</description></item><item><title>Type Providers - Tutorial Part 1 - Concepts</title><link>http://example.org/posts/2014-04-03-type-providers-tutorial-part-1/</link><pubDate>Thu, 03 Apr 2014 20:36:12 -0700</pubDate><guid>http://example.org/posts/2014-04-03-type-providers-tutorial-part-1/</guid><description>I&amp;rsquo;ve only been working with the F# language for the last year. Which means that all of my learning has been with version 3.x of the F# language. One of the biggest features of 3.x, and something which I have yet to work with, is the Type Provider. Type Providers dynamically generate new types, usually from some data source (e.g. databases, XML documents, web services), which a developer can use in their code.</description></item></channel></rss>