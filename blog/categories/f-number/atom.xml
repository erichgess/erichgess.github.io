<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: F# | Elegant Architecture]]></title>
  <link href="http://erichgess.github.io/blog/categories/f-number/atom.xml" rel="self"/>
  <link href="http://erichgess.github.io/"/>
  <updated>2016-04-14T10:02:41-04:00</updated>
  <id>http://erichgess.github.io/</id>
  <author>
    <name><![CDATA[Erich G. Ess]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[F# Data Structures: Set]]></title>
    <link href="http://erichgess.github.io/blog/2016/04/10/f-number-data-structures-set/"/>
    <updated>2016-04-10T11:15:48-04:00</updated>
    <id>http://erichgess.github.io/blog/2016/04/10/f-number-data-structures-set</id>
    <content type="html"><![CDATA[<h2 id="how-do-the-f-core-data-structures-work">How do the F# Core data structures work</h2>
<p>To help improve my understanding of functional programming, I’m reading
through Chris Okasaki’s <em>Purely Functional Data Structures</em>.  This book has been a great
refresher for my knowledge of data structures and algorithms.  Just for fun, I’m also
diving in the F# Core source code to see how many of the data structures that are covered
by Okasaki get implemented in real work functional source code.</p>

<p>Okasaki’s book starts with implementing a Set data structure with a binary search tree.
So this small series also starts with F#’s implementation of Set.</p>

<h2 id="what-are-the-important-and-interesting-parts-of-set">What are the important and interesting parts of Set?</h2>
<p>There are a lot of functions in F#’s <code>Set</code> type and many of them aren’t that interesting
and a dive into everything would make an over long post.  So we’ll focus on just a few
of the core <code>Set</code> functions.  <code>Add</code>, <code>Contains</code>, and <code>Remove</code> are not, on the surface,
interesting but they provide a great way to explain on the underlying data structure
used for <code>Set</code> is implemented.</p>

<h3 id="add">Add</h3>
<p>This function will add a new element to a Set, if it doesn’t already exist.  If it does
already exist in the Set then it, of course, won’t make any change to Set.</p>

<h3 id="contains">Contains</h3>
<p>Checks to see if a value is in the Set.</p>

<h3 id="remove">Remove</h3>
<p>Take a set and a value and if the value is in the set then return a new set without that
value.</p>

<h3 id="union">Union</h3>
<p>Take two sets and return a new set which contains all the values from both sets.</p>

<h3 id="intersect">Intersect</h3>
<p>Take two sets and return a new set which contains only the values that are in both sets.</p>

<h3 id="issubsetissuperset">IsSubset/IsSuperSet</h3>
<p>Takes two sets and returns true if all the values of one set are also in the other set.</p>

<h2 id="implemented-with-a-binary-search-tree">Implemented with a Binary Search Tree</h2>
<p>Starting with the actual definition for the <code>Set</code> type «<insert link="" to="" github="">&gt;&gt;.
Which is actually built out of the `SetTree` type.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;[&lt;</span><span class="n">equalityconditionalon</span><span class="o">&gt;]</span><span class="k">&#39;</span><span class="nc">T</span> <span class="k">when</span> <span class="k">&#39;</span><span class="nc">T</span> <span class="o">:</span> <span class="n">comparison</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">comparer</span><span class="o">:</span><span class="nc">IComparer</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="k">&#39;</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;,</span> <span class="n">tree</span><span class="o">:</span> <span class="nc">SetTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="k">&#39;</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></equalityconditionalon></insert></p>

<p>So skipping up to the definition of <code>SetTree</code>:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">SetTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">when</span> <span class="err">‘</span><span class="nc">T</span> <span class="o">:</span> <span class="n">comparison</span> <span class="o">=</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span>                                          <span class="c1">// height = 0 &lt;br /&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span> <span class="k">of</span> <span class="err">‘</span><span class="nc">T</span> <span class="o">*</span> <span class="nc">SetTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">*</span>  <span class="nc">SetTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">*</span> <span class="kt">int</span>    <span class="c1">// height = int </span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span>  <span class="k">of</span> <span class="err">‘</span><span class="nc">T</span>                                     <span class="c1">// height = 1 &lt;br /&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>So F#’s <code>Set</code> type is actually built out of a binary search tree which, as will be seen shortly,
is self balancing.  This is pretty much exactly how Okasaki implements Sets in his book.</p>

<h2 id="how-each-function-is-implemented">How each function is implemented</h2>
<p>We already know that <code>Set</code> is built on top of a binary search tree named <code>SetTree</code>, but
lets first take a look at how <code>Set</code> implements <code>Add</code>, <code>Contains</code>, and <code>Removes</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">member</span> <span class="n">s</span><span class="o">.</span><span class="nc">Add</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">s</span><span class="o">.</span><span class="nc">Comparer</span><span class="o">,</span><span class="nn">SetTree</span><span class="p">.</span><span class="n">add</span> <span class="n">s</span><span class="o">.</span><span class="nc">Comparer</span> <span class="n">x</span> <span class="n">s</span><span class="o">.</span><span class="nc">Tree</span> <span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">member</span> <span class="n">s</span><span class="o">.</span><span class="nc">Remove</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="nc">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">Set</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;(</span><span class="n">s</span><span class="o">.</span><span class="nc">Comparer</span><span class="o">,</span><span class="nn">SetTree</span><span class="p">.</span><span class="n">remove</span> <span class="n">s</span><span class="o">.</span><span class="nc">Comparer</span> <span class="n">x</span> <span class="n">s</span><span class="o">.</span><span class="nc">Tree</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">member</span> <span class="n">s</span><span class="o">.</span><span class="nc">Count</span> <span class="o">=</span> <span class="nn">SetTree</span><span class="p">.</span><span class="n">count</span> <span class="n">s</span><span class="o">.</span><span class="nc">Tree</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">member</span> <span class="n">s</span><span class="o">.</span><span class="nc">Contains</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>    <span class="nn">SetTree</span><span class="p">.</span><span class="n">mem</span> <span class="n">s</span><span class="o">.</span><span class="nc">Comparer</span>  <span class="n">x</span> <span class="n">s</span><span class="o">.</span><span class="nc">Tree</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>It’s not much surprise to see that <code>Set</code> just makes simple calls to <code>SetTree</code> for these
core actions.</p>

<h3 id="add-1">Add</h3>

<p>Here’s the implementation of <code>SetTree</code>’s <code>add</code> function:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">add</span> <span class="o">(</span><span class="n">comparer</span><span class="o">:</span> <span class="nc">IComparer</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span> <span class="n">k</span> <span class="n">t</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span> <span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">rebalance</span> <span class="o">(</span><span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">l</span><span class="o">)</span> <span class="n">k2</span> <span class="n">r</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">t</span>
</span><span class='line'>        <span class="k">else</span>            <span class="n">rebalance</span> <span class="n">l</span> <span class="n">k2</span> <span class="o">(</span><span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">// nb. no check for rebalance needed for small trees, also be sure to reuse node already allocated </span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span>   <span class="k">then</span> <span class="nc">SetNode</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="nc">SetEmpty</span><span class="o">,</span><span class="n">t</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">t</span>
</span><span class='line'>        <span class="k">else</span>            <span class="nc">SetNode</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">t</span><span class="o">,</span><span class="nc">SetEmpty</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>                <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Adding a value to an empty set just returns the leaf type, <code>SetOne</code>, which has
no children.</p>

<p>Adding a value to a tree which has only one value is also pretty simple:  a comparison is made to
see if <code>t</code>, the tree passed into the function, should be on the left or right branch.  It’s
important to note that by putting <code>t</code> as a child of the added value we get to reuse <code>t</code> and not
waste time or memory by creating a new node for that value.<br />
For the third case, the tree is complex enough to require checking for rebalancing when new
values are added.  Rebalancing insures that both branches of a tree are have nearly the same
height which keeps searches near the ideal of <code>n * log n</code>.</p>

<p>The <code>rebalance</code> function is critical and is also used by the <code>remove</code> function.  So now’s a great
time to cover how it works.  This function is the the most important part of the binary search
tree’s implementation (how a tree rebalances is the core difference between trees like AVL, red
black, and other search trees).</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="n">mk</span> <span class="n">l</span> <span class="n">k</span> <span class="n">r</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">l</span><span class="o">,</span><span class="n">r</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span><span class="o">,</span><span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">SetOne</span> <span class="o">(</span><span class="n">k</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>      <span class="k">let</span> <span class="n">hl</span> <span class="o">=</span> <span class="n">height</span> <span class="n">l</span>
</span><span class='line'>      <span class="k">let</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">height</span> <span class="n">r</span>
</span><span class='line'>      <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="k">if</span> <span class="n">hl</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">hr</span> <span class="k">then</span> <span class="n">hr</span> <span class="k">else</span> <span class="n">hl</span>
</span><span class='line'>      <span class="nc">SetNode</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">rebalance</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">t1h</span> <span class="o">=</span> <span class="n">height</span> <span class="n">t1</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">t2h</span> <span class="o">=</span> <span class="n">height</span> <span class="n">t2</span>
</span><span class='line'>    <span class="k">if</span>  <span class="n">t2h</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t1h</span> <span class="o">+</span> <span class="n">tolerance</span> <span class="k">then</span> <span class="c1">// right is heavier than left </span>
</span><span class='line'>        <span class="k">match</span> <span class="n">t2</span> <span class="k">with</span>
</span><span class='line'>        <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">t2k</span><span class="o">,</span><span class="n">t2l</span><span class="o">,</span><span class="n">t2r</span><span class="o">,&lt;</span><span class="n">em</span><span class="o">&gt;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>            <span class="c1">// one of the nodes must have height &amp;gt; height t1 + 1 </span>
</span><span class='line'>            <span class="k">if</span> <span class="n">height</span> <span class="n">t2l</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t1h</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">then</span>  <span class="c1">// balance left: combination </span>
</span><span class='line'>                <span class="k">match</span> <span class="n">t2l</span> <span class="k">with</span>
</span><span class='line'>                <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">t2lk</span><span class="o">,</span><span class="n">t2ll</span><span class="o">,</span><span class="n">t2lr</span><span class="o">,&lt;/</span><span class="n">em</span><span class="o">&gt;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2ll</span><span class="o">)</span> <span class="n">t2lk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t2lr</span> <span class="n">t2k</span> <span class="n">t2r</span><span class="o">)</span>
</span><span class='line'>                <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">failwith</span> <span class="err">“</span><span class="n">rebalance</span><span class="err">”</span>
</span><span class='line'>            <span class="k">else</span> <span class="c1">// rotate left </span>
</span><span class='line'>                <span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2l</span><span class="o">)</span> <span class="n">t2k</span> <span class="n">t2r</span>
</span><span class='line'>        <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">failwith</span> <span class="err">“</span><span class="n">rebalance</span><span class="err">”</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="k">if</span>  <span class="n">t1h</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t2h</span> <span class="o">+</span> <span class="n">tolerance</span> <span class="k">then</span> <span class="c1">// left is heavier than right </span>
</span><span class='line'>            <span class="k">match</span> <span class="n">t1</span> <span class="k">with</span>
</span><span class='line'>            <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">t1k</span><span class="o">,</span><span class="n">t1l</span><span class="o">,</span><span class="n">t1r</span><span class="o">,&lt;</span><span class="n">em</span><span class="o">&gt;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>                <span class="c1">// one of the nodes must have height &amp;gt; height t2 + 1 </span>
</span><span class='line'>                <span class="k">if</span> <span class="n">height</span> <span class="n">t1r</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t2h</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">then</span>
</span><span class='line'>                    <span class="c1">// balance right: combination </span>
</span><span class='line'>                    <span class="k">match</span> <span class="n">t1r</span> <span class="k">with</span>
</span><span class='line'>                    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">t1rk</span><span class="o">,</span><span class="n">t1rl</span><span class="o">,</span><span class="n">t1rr</span><span class="o">,&lt;/</span><span class="n">em</span><span class="o">&gt;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>                        <span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1l</span> <span class="n">t1k</span> <span class="n">t1rl</span><span class="o">)</span> <span class="n">t1rk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1rr</span> <span class="n">k</span> <span class="n">t2</span><span class="o">)</span>
</span><span class='line'>                    <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">failwith</span> <span class="err">“</span><span class="n">rebalance</span><span class="err">”</span>
</span><span class='line'>                <span class="k">else</span>
</span><span class='line'>                    <span class="n">mk</span> <span class="n">t1l</span> <span class="n">t1k</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1r</span> <span class="n">k</span> <span class="n">t2</span><span class="o">)</span>
</span><span class='line'>            <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">failwith</span> <span class="err">“</span><span class="n">rebalance</span><span class="err">”</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>mk</code> function takes two trees <code>l</code> and <code>r</code> and a value <code>k</code> and creates
a new tree and updates the new height value.</p>

<p><code>rebalance</code> also takes two trees, <code>t1</code> and <code>t2</code>, and a value <code>k</code>.  If the difference
between the heights of <code>t1</code> and <code>t2</code> is not greater than the <code>tolerance</code> (a parameter
for how much tolerance <code>SetTree</code> has for imbalance, then <code>rebalance</code> simply makes
a new tree with <code>t1</code> as the left and <code>t2</code> as the right branch, respectively, and <code>k</code>
as the value of the new root node.</p>

<p>If the difference in heights is greater than the tolerance then the tree needs to be
rebalanced.  We’ll just cover how the rebalance works when <code>t2</code> is taller than <code>t1</code>,
because the reverse case follows the exact same process.</p>

<p>The <code>match</code> expression is used to deconstruct <code>t2</code> into it’s value, <code>t2k</code>, and it’s 
left and right branches, <code>t2l</code> and <code>t2r</code>.  Now we check to see if the <code>t2l</code> or <code>t2r</code>
is taller than <code>t1</code> which determines how we’ll rebalance the tree.</p>

<p>If <code>t2r</code> is taller than <code>t1</code> then we’ll rotate the tree to the left with this code:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2l</span><span class="o">)</span> <span class="n">t2k</span> <span class="n">t2r</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>If <code>t2l</code> is taller than <code>t1</code> then the code is a little more complicated:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">if</span> <span class="n">height</span> <span class="n">t2l</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t1h</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">then</span>  <span class="c1">// balance left: combination </span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t2l</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">t2lk</span><span class="o">,</span><span class="n">t2ll</span><span class="o">,</span><span class="n">t2lr</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="n">mk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2ll</span><span class="o">)</span> <span class="n">t2lk</span> <span class="o">(</span><span class="n">mk</span> <span class="n">t2lr</span> <span class="n">t2k</span> <span class="n">t2r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Again <code>match</code> is used to deconstruct a tree node, <code>t2l</code>, into it’s components:
<code>t2lk</code> (the value) and <code>t2ll</code> and <code>t2lr</code> (the left and right branches of <code>t2l</code>.</p>

<p>Once the <code>t2l</code> is deconstructed <code>rebalance</code> creates a new tree:</p>

<ol>
  <li>The value of <code>t2l</code> becomes the new root of the tree.</li>
  <li>The left branch is a tree with the value <code>k</code>, this tree’s left branch is <code>t1</code>
and it’s right branch is <code>t2ll</code> (the left child of <code>t2l</code>, the left child of <code>t2</code>).</li>
  <li>The right branch is a tree with value <code>t2k</code>, which is the value of <code>t2</code>, and
this tree’s left branch is <code>t2lr</code> (the right child of <code>t2l</code>, the left child of <code>t2</code>)
and it’s left branch is <code>t2r</code> (the right branch of <code>t2</code>).</li>
</ol>

<p>This image visually illustrates what happens when <code>rebalance t1 k t2</code> is called:
<img src="/images/posts/fsharp_set/settree_rebalance_diagram.png"></p>

<h3 id="contains-1">Contains</h3>

<p>Set <code>Contains</code> function is just a call to the <code>SetTree</code> function <code>mem</code>.</p>

<p>Here’s <code>mem</code>:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">mem</span> <span class="o">(</span><span class="n">comparer</span><span class="o">:</span> <span class="nc">IComparer</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span> <span class="n">k</span> <span class="n">t</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">mem</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">l</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="bp">true</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">mem</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">r</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">(</span><span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="bp">false</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>mem</code> is the simplest of all these functions, because it doesn’t make any changes
to the tree and so it doesn’t trigger any rebalancing actions.</p>

<p><code>mem</code> recurively walks through the binary search tree using the comparer argument
to determine whether it should follow the left child or the right child or if the
value has been found.  If it reaches an edge node it compares the node with the
value argument and returns that as the result.  If it reaches an empty tree then
the value is not in the tree and false is returned.</p>

<h3 id="remove-1">Remove</h3>
<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">remove</span> <span class="o">(</span><span class="n">comparer</span><span class="o">:</span> <span class="nc">IComparer</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span> <span class="n">k</span> <span class="n">t</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span> <span class="o">(</span><span class="n">k2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">SetEmpty</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">t</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span> <span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,&lt;</span><span class="n">em</span><span class="o">&gt;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">rebalance</span> <span class="o">(</span><span class="n">remove</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">l</span><span class="o">)</span> <span class="n">k2</span> <span class="n">r</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span>
</span><span class='line'>          <span class="k">match</span> <span class="n">l</span><span class="o">,</span><span class="n">r</span> <span class="k">with</span>
</span><span class='line'>          <span class="o">|</span> <span class="nc">SetEmpty</span><span class="o">,&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">r</span>
</span><span class='line'>          <span class="o">|</span> <span class="o">_,</span><span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">l</span>
</span><span class='line'>          <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>              <span class="k">let</span> <span class="n">sk</span><span class="o">,</span><span class="n">r</span><span class="err">’</span> <span class="o">=</span> <span class="n">spliceOutSuccessor</span> <span class="n">r</span>
</span><span class='line'>              <span class="n">mk</span> <span class="n">l</span> <span class="n">sk</span> <span class="n">r</span><span class="err">’</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">rebalance</span> <span class="n">l</span> <span class="n">k2</span> <span class="o">(</span><span class="n">remove</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="union-1">Union</h3>
<p><code>Set.Union</code> might be the most complex of all the functions in <code>Set</code>.  Like
<code>add</code> and <code>remove</code> it makes use of helper functions which contain most of
the major complexity.  Below is the code for <code>SetTree.union</code> the code for the
two helper functions is further down, in this section, but we’ll cover the
cases in <code>union</code> that don’t reqiure the helper functions first.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">union</span> <span class="n">comparer</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span>
</span><span class='line'>    <span class="c1">// Perf: tried bruteForce for low heights, but nothing significant </span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>             <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span><span class="n">t11</span><span class="o">,</span><span class="n">t12</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span><span class="nc">SetNode</span><span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">t21</span><span class="o">,</span><span class="n">t22</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="c1">// (t11 &amp;lt; k &amp;lt; t12) AND (t21 &amp;lt; k2 &amp;lt; t22) </span>
</span><span class='line'>        <span class="c1">// Divide and Conquer:</span>
</span><span class='line'>        <span class="c1">//   Suppose t1 is largest.</span>
</span><span class='line'>        <span class="c1">//   Split t2 using pivot k1 into lo and hi.</span>
</span><span class='line'>        <span class="c1">//   Union disjoint subproblems and then combine. </span>
</span><span class='line'>        <span class="k">if</span> <span class="n">h1</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">h2</span> <span class="k">then</span>
</span><span class='line'>          <span class="k">let</span> <span class="n">lo</span><span class="o">,&lt;</span><span class="n">em</span><span class="o">&gt;,</span><span class="n">hi</span> <span class="o">=</span> <span class="n">split</span> <span class="n">comparer</span> <span class="n">k1</span> <span class="n">t2</span> <span class="k">in</span>
</span><span class='line'>          <span class="n">balance</span> <span class="n">comparer</span> <span class="o">(</span><span class="n">union</span> <span class="n">comparer</span> <span class="n">t11</span> <span class="n">lo</span><span class="o">)</span> <span class="n">k1</span> <span class="o">(</span><span class="n">union</span> <span class="n">comparer</span> <span class="n">t12</span> <span class="n">hi</span><span class="o">)</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="k">let</span> <span class="n">lo</span><span class="o">,&lt;/</span><span class="n">em</span><span class="o">&gt;,</span><span class="n">hi</span> <span class="o">=</span> <span class="n">split</span> <span class="n">comparer</span> <span class="n">k2</span> <span class="n">t1</span> <span class="k">in</span>
</span><span class='line'>          <span class="n">balance</span> <span class="n">comparer</span> <span class="o">(</span><span class="n">union</span> <span class="n">comparer</span> <span class="n">t21</span> <span class="n">lo</span><span class="o">)</span> <span class="n">k2</span> <span class="o">(</span><span class="n">union</span> <span class="n">comparer</span> <span class="n">t22</span> <span class="n">hi</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span><span class="o">,</span><span class="n">t</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">t</span><span class="o">,</span><span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">t</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span> <span class="n">k1</span><span class="o">,</span><span class="n">t2</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k1</span> <span class="n">t2</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">t1</span><span class="o">,</span><span class="nc">SetOne</span> <span class="n">k2</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k2</span> <span class="n">t1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>union</code> takes two trees, <code>t1</code> and <code>t2</code>, and puts them together as a tuple and
then de-structures that tuple.  This function is only complicated if both
<code>t1</code> and <code>t2</code> have children, for all other cases it’s extremely simple.</p>

<p>Here are the simple patterns that <code>(t1,t2)</code> can match against
1.  <code>SetEmpty,t</code> or <code>t,SetEmpty</code>: because one of the two sets is empty, the union
is just whatever the value of the other set is.
1.  <code>SetOne k1,t2</code> or `t1,SetOne k2: one of the trees contains a single value,
so the union is can be gotten, efficiently, by just adding that value to the 
other tree.</p>

<p>The one remaining case is the complicated interesting one.  Obviously, the union
could be found by simply traversing the first tree and adding every value to the second
tree.  But the F# compiler is being more efficient in it’s solution to this problem.
That’s where the two helper fuctions, <code>balance</code> and <code>split</code>, come into play and their
code is listed below.</p>

<p>Note that <code>balance</code> calls <code>rebalance</code>, whose code is listed above.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">balance</span> <span class="n">comparer</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2</span> <span class="o">=</span>
</span><span class='line'>    <span class="c1">// Given t1 &amp;lt; k &amp;lt; t2 where t1 and t2 are “balanced”,</span>
</span><span class='line'>    <span class="c1">// return a balanced tree for &amp;lt;t1,k,t2&amp;gt;.</span>
</span><span class='line'>    <span class="c1">// Recall: balance means subtrees heights differ by at most “tolerance”</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t1</span><span class="o">,</span><span class="n">t2</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span><span class="o">,</span><span class="n">t2</span>  <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">t2</span> <span class="c1">// drop t1 = empty </span>
</span><span class='line'>    <span class="o">|</span> <span class="n">t1</span><span class="o">,</span><span class="nc">SetEmpty</span>  <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">t1</span> <span class="c1">// drop t2 = empty </span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span> <span class="n">k1</span><span class="o">,</span><span class="n">t2</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="o">(</span><span class="n">add</span> <span class="n">comparer</span> <span class="n">k1</span> <span class="n">t2</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="n">t1</span><span class="o">,</span><span class="nc">SetOne</span> <span class="n">k2</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="o">(</span><span class="n">add</span> <span class="n">comparer</span> <span class="n">k2</span> <span class="n">t1</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span><span class="n">t11</span><span class="o">,</span><span class="n">t12</span><span class="o">,</span><span class="n">h1</span><span class="o">),</span><span class="nc">SetNode</span><span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">t21</span><span class="o">,</span><span class="n">t22</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="c1">// Have:  (t11 &amp;lt; k1 &amp;lt; t12) &amp;lt; k &amp;lt; (t21 &amp;lt; k2 &amp;lt; t22)</span>
</span><span class='line'>        <span class="c1">// Either (a) h1,h2 differ by at most 2 - no rebalance needed.</span>
</span><span class='line'>        <span class="c1">//        (b) h1 too small, i.e. h1+2 &amp;lt; h2</span>
</span><span class='line'>        <span class="c1">//        (c) h2 too small, i.e. h2+2 &amp;lt; h1 </span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">h1</span><span class="o">+</span><span class="n">tolerance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">h2</span> <span class="k">then</span>
</span><span class='line'>            <span class="c1">// case: b, h1 too small </span>
</span><span class='line'>            <span class="c1">// push t1 into low side of t2, may increase height by 1 so rebalance </span>
</span><span class='line'>            <span class="n">rebalance</span> <span class="o">(</span><span class="n">balance</span> <span class="n">comparer</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t21</span><span class="o">)</span> <span class="n">k2</span> <span class="n">t22</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">h2</span><span class="o">+</span><span class="n">tolerance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">h1</span> <span class="k">then</span>
</span><span class='line'>            <span class="c1">// case: c, h2 too small </span>
</span><span class='line'>            <span class="c1">// push t2 into high side of t1, may increase height by 1 so rebalance </span>
</span><span class='line'>            <span class="n">rebalance</span> <span class="n">t11</span> <span class="n">k1</span> <span class="o">(</span><span class="n">balance</span> <span class="n">comparer</span> <span class="n">t12</span> <span class="n">k</span> <span class="n">t2</span><span class="o">)</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="c1">// case: a, h1 and h2 meet balance requirement </span>
</span><span class='line'>            <span class="n">mk</span> <span class="n">t1</span> <span class="n">k</span> <span class="n">t2</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="o">(</span><span class="n">comparer</span> <span class="o">:</span> <span class="nc">IComparer</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="nc">T</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;)</span> <span class="n">pivot</span> <span class="n">t</span> <span class="o">=</span>
</span><span class='line'>    <span class="c1">// Given a pivot and a set t</span>
</span><span class='line'>    <span class="c1">// Return { x in t s.t. x &amp;lt; pivot }, pivot in t? , { x in t s.t. x &amp;gt; pivot } </span>
</span><span class='line'>    <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span><span class="n">t11</span><span class="o">,</span><span class="n">t12</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">pivot</span><span class="o">,</span><span class="n">k1</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="k">then</span> <span class="c1">// pivot t1 </span>
</span><span class='line'>            <span class="k">let</span> <span class="n">t11Lo</span><span class="o">,</span><span class="n">havePivot</span><span class="o">,</span><span class="n">t11Hi</span> <span class="o">=</span> <span class="n">split</span> <span class="n">comparer</span> <span class="n">pivot</span> <span class="n">t11</span>
</span><span class='line'>            <span class="n">t11Lo</span><span class="o">,</span><span class="n">havePivot</span><span class="o">,</span><span class="n">balance</span> <span class="n">comparer</span> <span class="n">t11Hi</span> <span class="n">k1</span> <span class="n">t12</span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="c1">// pivot is k1 </span>
</span><span class='line'>            <span class="n">t11</span><span class="o">,</span><span class="bp">true</span><span class="o">,</span><span class="n">t12</span>
</span><span class='line'>        <span class="k">else</span>            <span class="c1">// pivot t2 </span>
</span><span class='line'>            <span class="k">let</span> <span class="n">t12Lo</span><span class="o">,</span><span class="n">havePivot</span><span class="o">,</span><span class="n">t12Hi</span> <span class="o">=</span> <span class="n">split</span> <span class="n">comparer</span> <span class="n">pivot</span> <span class="n">t12</span>
</span><span class='line'>            <span class="n">balance</span> <span class="n">comparer</span> <span class="n">t11</span> <span class="n">k1</span> <span class="n">t12Lo</span><span class="o">,</span><span class="n">havePivot</span><span class="o">,</span><span class="n">t12Hi</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span> <span class="n">k1</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">comparer</span><span class="o">.</span><span class="nc">Compare</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span><span class="n">pivot</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span>   <span class="n">c</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">t</span>       <span class="o">,</span><span class="bp">false</span><span class="o">,</span><span class="nc">SetEmpty</span> <span class="c1">// singleton under pivot </span>
</span><span class='line'>        <span class="k">elif</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">SetEmpty</span><span class="o">,</span><span class="bp">true</span> <span class="o">,</span><span class="nc">SetEmpty</span> <span class="c1">// singleton is    pivot </span>
</span><span class='line'>        <span class="k">else</span>            <span class="nc">SetEmpty</span><span class="o">,</span><span class="bp">false</span><span class="o">,</span><span class="n">t</span>        <span class="c1">// singleton over  pivot </span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span>  <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="nc">SetEmpty</span><span class="o">,</span><span class="bp">false</span><span class="o">,</span><span class="nc">SetEmpty</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h4 id="split">Split</h4>
<p>Of the two helper functions, <code>split</code> is the easiest.  It simply takes a tree, <code>t</code>,
and a value, <code>pivot</code>, and splits <code>t</code> into two subtrees:  one with all the values
that are greater than <code>pivot</code> and one with all the values smaller than <code>pivot</code>.
It evaluates to a tuple which contains those two trees and a boolean flag for if
<code>pivot</code> is in <code>t</code>.</p>

<h4 id="balance">Balance</h4>
<p>This function is more complex than <code>split</code> and just looking at the code it’s not
immediately obvious what purpose it plays.  <code>balance</code> takes 3 key arguments:
two trees, <code>t1</code> and <code>t2</code>, and a value, <code>k</code>.  These arguments must satisfy certain
requirements: every value in <code>t1</code> is smaller than every value in <code>t2</code> and k
is larger than every value in <code>t1</code> and smaller than every value in <code>t2</code>.
It basically takes two trees and a value
and puts them together into a single tree which is balanced.  The trivial cases
are when one of the trees is empty or contains only a single value.  The complex
case is when both trees contain multiple values.  <code>balance</code>’s goal is to add the
two tree’s together into a single balanced tree.  So it looks at the heights of 
the two trees to see how much they differ:  if the heights of the two trees are within
the tolerance then it can simply make <code>k</code> a new root node and set the two trees
as the left and right children of <code>k</code>.</p>

<p>If the two trees differ in height by more than
the tolerance then <code>balance</code> has to do some extra work in order to evaluate to
a balanced tree.  It takes the smaller tree and makes it the child of the larger
tree, then does a rebalance in case the result is unbalanced.</p>

<h4 id="final-union-case">Final Union Case</h4>

<h3 id="intersect-1">Intersect</h3>
<p>The <code>Set.Intersect a b</code> function takes two sets <code>a</code> and <code>b</code> and returns a new set
consisting of all the values which are in both <code>a</code> and <code>b</code>.  Intuitively, this
function seems like it will behave nearly identically to <code>Subset</code>: both functions
involve traversing two sets and finding all the elements that are in both sets. This
function merely needs to save all the elements that are in both sets rather than 
return a boolean value.</p>

<p>Below is the code from <code>FSharp.Core</code> for <code>SetTree</code> intersection.  Note that the real
work is done by the function <code>intersectionAux</code> the <code>intersection</code> function is used
to set the initial value for the accumulator argument to <code>SetEmpty</code>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">intersectionAux</span> <span class="n">comparer</span> <span class="n">b</span> <span class="n">m</span> <span class="n">acc</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">intersectionAux</span> <span class="n">comparer</span> <span class="n">b</span> <span class="n">r</span> <span class="n">acc</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">if</span> <span class="n">mem</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">b</span> <span class="k">then</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">acc</span>
</span><span class='line'>        <span class="n">intersectionAux</span> <span class="n">comparer</span> <span class="n">b</span> <span class="n">l</span> <span class="n">acc</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">mem</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">b</span> <span class="k">then</span> <span class="n">add</span> <span class="n">comparer</span> <span class="n">k</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">acc</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">acc</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">intersection</span> <span class="n">comparer</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">intersectionAux</span> <span class="n">comparer</span> <span class="n">b</span> <span class="n">a</span> <span class="nc">SetEmpty</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>intersectionAux</code> takes the two sets, note that the labelling has changed to <code>b</code> and
<code>m</code>, and the accumulator argument, which will collect all the values which are in both
<code>b</code> and <code>m</code>.  <code>intersectionAux</code> traverses the tree <code>m</code> and for each value, <code>k</code>, in <code>m</code>
it checks to see if the value is also in <code>b</code>.  If <code>k</code> is in <code>b</code> then it’s added to
the accumulator, <code>acc</code>, otherwise it’s left out.  After completing the traversal of
<code>m</code>, <code>acc</code> will represent the intersection of <code>m</code> and <code>b</code>.</p>

<p>The argument <code>m</code> is deconstructed using <code>match</code> into it’s possible values: <code>SetEmpty</code>,
<code>SetOne</code>, and <code>SetNode</code>.  If it’s <code>SetEmpty</code> then there is no value in the node and
the only thing to do is return <code>acc</code>.  If it’s <code>SetOne</code> we extract the value into <code>k</code>
and check if <code>k</code> exists in the set <code>b</code>:  if it does then add it to <code>acc</code> if it’s not
in <code>b</code> then just return <code>acc</code> with no additions. Finally, if it’s <code>SetNode</code> extract 
the value, <code>k</code>, and the children, <code>l</code> and <code>r</code>. Then
recursively call <code>intersectionAux</code> on <code>r</code> and add any elements that are in <code>r</code> and <code>b</code>
to <code>acc</code>.  Check if <code>k</code> is in <code>b</code> and if it is, add it to <code>acc</code>.  Finally, call
<code>intersectionAux</code> on <code>l</code> and add any values which are in both <code>l</code> and <code>b</code> to <code>acc</code>.</p>

<h3 id="issubsetissuperset-1">IsSubset/IsSuperSet</h3>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">forall</span> <span class="n">f</span> <span class="n">m</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span> <span class="n">k2</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">forall</span> <span class="n">f</span> <span class="n">l</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">forall</span> <span class="n">f</span> <span class="n">r</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span> <span class="n">k2</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="bp">true</span>          <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="k">rec</span> <span class="n">exists</span> <span class="n">f</span> <span class="n">m</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">match</span> <span class="n">m</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetNode</span><span class="o">(</span><span class="n">k2</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">,_)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span> <span class="n">k2</span> <span class="o">||</span> <span class="n">exists</span> <span class="n">f</span> <span class="n">l</span> <span class="o">||</span> <span class="n">exists</span> <span class="n">f</span> <span class="n">r</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetOne</span><span class="o">(</span><span class="n">k2</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">f</span> <span class="n">k2</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">SetEmpty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="bp">false</span>         <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">subset</span> <span class="n">comparer</span> <span class="n">a</span> <span class="n">b</span>  <span class="o">=</span> <span class="n">forall</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">mem</span> <span class="n">comparer</span> <span class="n">x</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>These two functions aren’t that difficult to understand.  Much like <code>mem</code>
they don’t modify the tree so there’s no need for rebalancing.</p>

<p><code>subset</code> traverses every node in <code>a</code> and checks to see if that node’s value
also exists in <code>b</code>.  <code>forall</code> will short circuit if it hits a node which is
not in <code>b</code> and will evaluate to <code>false</code>.</p>

<p>The SuperSet function is exactly the same except it swaps the arguments and
tests if <code>b</code> is a subset of <code>a</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>What’s awesome is that, fundamentally, this is the same way that sets are
implemented in <em>Purely Functional Data Structures</em>.  Which just shows how
valuable that book still is, even with it being 20 years old!</p>

<p>The most important difference, of course, is that the book doesn’t use a
self balancing binary search tree while F# uses an AVL tree.  But no one
would use a non-self balancing BST in a real implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Purely Functional Data Structures: Chapter 2 - Binary Search Trees]]></title>
    <link href="http://erichgess.github.io/blog/2016/03/21/purely-functional-data-structures-chapter-2-binary-search-trees/"/>
    <updated>2016-03-21T22:41:37-04:00</updated>
    <id>http://erichgess.github.io/blog/2016/03/21/purely-functional-data-structures-chapter-2-binary-search-trees</id>
    <content type="html"><![CDATA[<p>The second section of Chapter 2 deals focuses on binary search trees (BST) and uses BSTs to
implement a set data structure.  Like the section
on lists, this gives a nice little explanation on how to deal with inserts to a tree data
structure when the data is immutable in as efficient a way as possible.  The most brute
force solution to this would be to create a complete duplicate of the tree save for the
newly added value, this section shows that, while copying is necessary, only the search
path from the root to the new element needs to be copied.  The new tree will then reference
as much of the old tree as possible; minimizing both copies and memory used.</p>

<p>What this post will cover:  how to represent a binary search tree (BST) in F#, how to efficiently
update the BST while using immutable data structures, and some discussion on design and style.</p>

<!-- more -->

<p>First thing:  how to represent the binary search tree in F#.  A BST has two possible values:
it’s either Empty or it’s a some value with 2 children.  So a discriminated union captures
this set and a tuple can store the value and 2 children.  Leading, as with the list, to
a recursive type:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">Tree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Tree</span> <span class="k">of</span> <span class="nc">Tree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">*</span> <span class="err">‘</span><span class="n">a</span> <span class="o">*</span> <span class="nc">Tree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The Tree on the left of <code>Tree&lt;'a&gt; * 'a * Tree&lt;'a&gt;</code> stores the left branch and the right
<code>Tree</code> stores the right branch.</p>

<p>A requirement for a BST is that <code>'a</code> must have a total ordering:  you must be able to take
any two values of type <code>'a</code> and check if one is less than the other.  The above definition
does not capture this requirement and so we can make a <code>Tree</code> of any type.  In Purely
Functional Data Structure this is solved by using ML’s <em>functor</em> feature, which F# doesn’t
have.  In F# this can be captured using a <em>constraint</em> on the type:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">BinarySearchTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span> <span class="k">when</span> <span class="err">‘</span><span class="n">a</span><span class="o">:</span> <span class="n">comparison</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Tree</span> <span class="k">of</span> <span class="nc">BinarySearchTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">*</span> <span class="err">‘</span><span class="n">a</span> <span class="o">*</span> <span class="nc">BinarySearchTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>'a when 'a: comparison</code> tells the F# compiler that <code>'a</code> must implement the IComparable
interface which guarantees that the <code>&lt;</code> operator can be used on two values of type <code>'a</code>.</p>

<p>I changed the name of the type from <code>Tree</code> to <code>BinarySearchTree</code> to capture the more focused
nature of the type when a constraint is added.  The <code>Tree</code> can be use to create any type of
binary tree structure, with the constraint the type becomes focused specifically on ordering
and searching.  The updated name helps to reflect this focus.  This type could also be put
into a <code>module</code> named <em>BinarySearchTree</em> to capture that information and then keep the type
named simply <em>Tree</em>.  However, I am not yet sure which is superior, though I feel that
capturing the nature of the type, intrinsically, in the name so that it can’t be seperated
is the better path to follow.</p>

<p>As a note, there is another option with F# for capturing the comparability requirement. We
don’t have to put the constraint in the type definition.  When we write our <code>insert</code> and
<code>search</code> functions, the F# compiler with infer that, for <em>those</em> functions, <code>'a</code> must
have the <code>comparison</code> constraint.  This decouples the use of the tree from the type definition.
If we want the type to capture only the structure of a binary tree, then this approach makes
sense.  However, if we want the type to capture both the structure and the purpose (searching)
then this approach seems like it will be fragile and confusing.</p>

<p>I initially thought that there was a third option:  add the search and insert functions as
member methods to the definition of <code>Tree</code>.  It seemed likely that the F# compiler would
infer that <code>'a</code> must have the <code>comparison</code> constraint.  Testing proved that this is not the
case and, in fact, the compiler throws an error because <code>Tree</code> must explicitly have the
<code>comparison</code> constraint in order for the member methods to work.</p>

<h3 id="ismember">IsMember</h3>
<p>Checking membership in the tree is the first of the two absolutely necessary functions
for our BST.  The logic is rather simple, but here I’ve started trying out the <code>function</code>
  structure for when I’m writing a “polymorphic” function and leaving out explicity
  parameters.  I rarely used the <code>function</code> expression in the past so this is helping
  me to get a feel for this as a part of my toolbox.</p>

<p>Leaving out the parameters in the 
function definition is the <a href="https://en.wikipedia.org/wiki/Tacit_programming">point free</a> 
style of programming.  Since point free style cuts out one source of self documentation
in code, I’m not sure I really like it.  However, it fits well with the <code>function</code> expression
since the focus is the <em>patterns</em> that are being matched and that documents the parameters
well enough.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">isMember</span> <span class="o">=</span> <span class="k">function</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="nc">Empty</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="bp">false</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">isMember</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span>   <span class="c1">// Experimenting with a new format for if/then.  I like having the condition and it’s direct conclusion on the same line</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">isMember</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="bp">true</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3 id="insert">Insert</h3>
<p>The insert function is a little more complex than <code>isMember</code>:  it needs to handle inserting
a new value into an immutable tree data structure:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">s</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Tree</span> <span class="o">(</span><span class="nc">Empty</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">insert</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">l</span><span class="o">),</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">insert</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">r</span><span class="o">))</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">s</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<code>insert</code> travels from the root node, down the tree, visiting only the nodes on the way to
where the new node will get inserted.  This is called the <em>search path</em>.  As it moves, 
<code>insert</code> makes a copy of each node on the search path.  The nodes are copied so that they
can store the path to the new value, the nodes on the search path are the minimum number
of nodes that need to be copied.  And of course, because data is immutable, we have to
copy some nodes in order to make our insert.</p>

<p>This diagram shows what’s happening in a nicely visual form.  The brown nodes are the
copied nodes on the search path, the dashed lines represent the new links in those nodes.
Note that most of the original tree remains used in the new ‘post insert’ tree.  A copy of
<code>7</code> was made and it’s left child is the new <code>5</code> node, then a copy of <code>4</code> is made so that
<code>4</code>’s right points to the new <code>7</code>.  <code>4</code>’s left still points to the old tree.
<img src="/images/posts/purefds_ch2/bst_insert.png"></p>

<h3 id="problem-22">Problem 2.2</h3>
<p>In this problem, we have to update <code>isMember</code> to reduce the number of conditions in the
execution path.  This is done by propagating the last checked value through the traversal
and removing the <code>&gt;</code> check:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="n">isMember2</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="k">rec</span> <span class="n">check</span> <span class="o">=</span> <span class="k">function</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="bp">false</span><span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">prev</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>  <span class="n">x</span> <span class="o">=</span> <span class="n">prev</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">r</span><span class="o">))</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">check</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">check</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">check</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><code>isMember2</code> was my first attempt.  While the last pattern matching expression has only
one conditional rather than two, it also has an additional pattern match check and so
it seems unlikely that the number of condition checks is actually reduced.  I took a look
at the IL for this code and verified that it does indeed have just as many conditions
as `isMember.  The worst part is, that pattern match check must get executed every time.</p>

<p>My second attempt became less idiomatic but it successfully reduces the number of 
required conditionals:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">isMember2</span><span class="err">’</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">:</span> <span class="err">‘</span><span class="n">a</span> <span class="n">option</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>  <span class="k">if</span> <span class="n">prev</span><span class="o">.</span><span class="nc">IsSome</span> <span class="k">then</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="nc">Value</span> <span class="k">else</span> <span class="bp">false</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">r</span><span class="o">))</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">isMember2</span><span class="err">’</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">isMember2</span><span class="err">’</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>While working on this code, I noticed that in F# I’m much more comfortable writing
<code>if</code> expressions on a single line.  In other languages, I almost never do this (not
counting the ternary operator in the C family).</p>

<h3 id="problem-23-improving-insert">Problem 2.3: improving insert</h3>
<p>If we insert a value that’s already in the tree, then the resulting tree will be
identical to the input tree.  However, the current <code>insert</code> function will still
copy all the nodes on the search path.  This problem Okasaki has us fix that by
throwing a fault if the value is already in the tree.  This will bubble a break
up through the recursive path and break the execution path before any copies
are made:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">insert2</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">s</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Tree</span> <span class="o">(</span><span class="nc">Empty</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">insert2</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">l</span><span class="o">),</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="k">elif</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">n</span> <span class="k">then</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">insert2</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">r</span><span class="o">))</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">failwith</span> <span class="err">“</span><span class="nc">Element</span> <span class="n">already</span> <span class="n">exists</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally, we combine this update with the update to <code>isMember</code> to optimize insertion
even more:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">insert3</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">:</span> <span class="err">‘</span><span class="n">a</span> <span class="n">option</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">if</span> <span class="n">prev</span><span class="o">.</span><span class="nc">IsSome</span> <span class="o">&amp;</span><span class="n">amp</span><span class="o">;&amp;</span><span class="n">amp</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="nc">Value</span>
</span><span class='line'>             <span class="k">then</span> <span class="n">failwith</span> <span class="err">“</span><span class="nc">Element</span> <span class="n">already</span> <span class="n">exists</span><span class="err">”</span>
</span><span class='line'>             <span class="k">else</span> <span class="nc">Tree</span> <span class="o">(</span><span class="nc">Empty</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">n</span>
</span><span class='line'>    <span class="k">then</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">insert3</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="n">l</span><span class="o">),</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="nc">Tree</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">insert3</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Some</span> <span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Purely Functional Data Structures: Chapter 2 - Lists]]></title>
    <link href="http://erichgess.github.io/blog/2016/03/21/purely-functional-data-structures-chapter-2-lists/"/>
    <updated>2016-03-21T21:40:30-04:00</updated>
    <id>http://erichgess.github.io/blog/2016/03/21/purely-functional-data-structures-chapter-2-lists</id>
    <content type="html"><![CDATA[<p>Chapter 2 covers the efficient implementation of stack and binary search 
trees when your data structures
must be immutable.  This chapter wound up being a lot of fun to work on because
it helped me focus a lot on how to approach structuring my F# code and start
laying the foundation for how to approach building elegant F# code.</p>

<!-- more -->

<h2 id="stacks">Stacks</h2>
<p>There are two implementations of the stack in this chapter.  The first is
rather uninteresting and the second is significantly more educational.  This
section on Lists appeared to be more focused on using lists to represent
other data structures in this case to build a stack data structure.</p>

<h3 id="using-lists">Using Lists</h3>
<p>The first implementation is merely built on top of the existing list
data structure.  Below is the direct conversion into F#:</p>

<p><code>fsharp
module Lists =
  type ListStack&lt;'a&gt; =
    'a list
  let Empty:ListStack&lt;_&gt; = []
  let isEmpty s = List.isEmpty s
  let cons a s:ListStack&lt;_&gt; = a :: s
  let hd s = List.head s
  let tl s = List.tail s
</code></p>

<p>There really wasn’t a whole lot of interesting stuff in this first example.</p>

<h3 id="custom-stack">Custom Stack</h3>
<p>The second section is much more fun:  a custom data structure is built to
represent the stack.  Built as a recursively nested tuple.  Which is
actually identical to the traditional way of representing a regular list.
This provides a nice way of building up an immutable list from primitives
(tuples) in order to build a more complex data structure (a stack).</p>

<p>This was also the first part where I had an opportunity to experiment
with how to write this well in F# and reason through the pros and cons
of a specific approach.  My first attempt was to get as close to the 
book as possible and I used a <code>type</code> with member methods to group the
<code>CustomStack</code> with its associated functions.  The second approach uses
<code>module CustomStack</code> to group the type with the associated functions.</p>

<p>```fsharp
type CustomStack&lt;’a&gt; =
  | Empty
  | Cons of ‘a * CustomStack&lt;’a&gt;
with
  static member empty = Empty
  // Note:
  // I tried naming this IsEmpty but it won’t compile
  // F# auto generates Is* functions for each element of a DU.
  static member CheckEmpty = function
                          | Empty -&gt; true
                          | _ -&gt; false</p>

<p>static member cons (x, s) =
    Cons(x, s)</p>

<p>static member head = function
    | Empty -&gt; failwith “empty”
    | Cons(x, _) -&gt; x</p>

<p>static member tail s =
    match s with
    | Empty -&gt; failwith “empty”
    | Cons(x, Empty) -&gt; x
    | Cons(x, s) -&gt; CustomStack&lt;’a&gt;.tail s
```</p>

<p>The first thing I learned was that the F# compiler autogenerates a function
called <code>IsEmpty</code>.  Despite working with the language for several months,
I’d somehow never noticed that when you create a discriminated union type
F# automatically adds member methods for check if a value is a specific
element in the discriminated union.</p>

<p>Using static member methods to group the related functions to the type didn’t
feel particularly elegant:  you’d always have to prepend all calls to functions
with <code>CustomStack.</code>.  So I tried using another approach:  using a 
module named <code>CustomStack</code> to group the functions with the type.  This would
provide the option of just calling the functions or prepending the module
name (<code>CustomStack.</code>).</p>

<p>```fsharp
module CustomStack =
  type CustomStack&lt;’a&gt; = Empty | Cons of ‘a * CustomStack&lt;’a&gt;
  let empty = Empty</p>

<table>
  <tbody>
    <tr>
      <td>let isEmpty = function Empty -&gt; true</td>
      <td>_ -&gt; false</td>
    </tr>
  </tbody>
</table>

<p>let cons (x,s) = Cons(x, s)</p>

<p>let head = function
    | Empty -&gt; failwith “empty”
    | Cons(x,_) -&gt; x</p>

<p>let tail = function
    | Empty -&gt; failwith “empty”
    | Cons(_, s) -&gt; s</p>

<p>let rec (++) a b =
    match a with
    | Empty -&gt; b
    | Cons(x, s) -&gt; Cons(x, s ++ b)</p>

<p>let rec update = function
    | (Empty, <em>, _) -&gt; failwith “subscript is invalid”
    | (Cons(</em>, s), 0, x) -&gt; Cons(x, s)
    | (Cons(_, s), i, x) when i &gt; 0 -&gt; update (s, i-1, x)
    | _ -&gt; failwith “subscript is invalid”
```</p>

<p>This version felt much better to me, I also took the opportunity to create
an operator <code>++</code> for appends.  There is an interesting consequence that
this approach creates by disconnecting the type parameter restrictions
that functions require from the type definition; this will come up
explicitly in the binary search trees section.</p>

<p>I tried a slightly different format for <code>type CustomStack</code> and <code>isEmpty</code>:
placing the patterns on one line.  I’m not sure how I feel about
this approach.  It seems very easy to miss the <code>|</code> and not properly
see the pattern definitions.  Having everything on one line also
implies that everything is part of the same operation and that is
decidely not the case with pattern matching and DU definitions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pattern Matching With Pipes]]></title>
    <link href="http://erichgess.github.io/blog/2016/03/19/pattern-matching-with-pipes/"/>
    <updated>2016-03-19T12:09:26-04:00</updated>
    <id>http://erichgess.github.io/blog/2016/03/19/pattern-matching-with-pipes</id>
    <content type="html"><![CDATA[<p>One of my favorite things to do in F# is pipe functions together.  I like the elegant flow that the
semantics visualizes and the fact that it removes the need for intermediate variables.  Given that,
one of the minor, but consistent, annoyances I’ve had is when piping a DU type which generally need
to be piped into a pattern match expression.  This is annoying because the <code>match</code> expression doesn’t
lend itself to piping which has meant that my nice workflow needs to be broken up with an intermediate
variable that can be used in the <code>match</code> expression.</p>

<p>Looking at some old code I wrote, I just realized something that is probably pretty obvious to every
experienced F# programmer out there.  The <code>function</code> expression actually does exactly what <code>match</code> does
but it creates a function and that’s exactly what I’ve been wanting this whole time!</p>

<!-- more -->

<p>Here is a quick and dirty example of using a function which takes a value and returns  a discriminated
union.  The type of function which almost always means that pattern matching will have to be done with
its result:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">DU</span> <span class="o">=</span>
</span><span class='line'><span class="o">|</span> <span class="nc">A</span> <span class="k">of</span> <span class="kt">int</span>
</span><span class='line'><span class="o">|</span> <span class="nc">B</span> <span class="k">of</span> <span class="kt">string</span>
</span><span class='line'><span class="o">|</span> <span class="nc">C</span> <span class="k">of</span> <span class="kt">bool</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">doSomething</span> <span class="n">x</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">x</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">A</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="n">x</span> <span class="k">when</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">B</span><span class="o">(</span><span class="err">“</span><span class="n">zero</span><span class="err">”</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="o">_</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">C</span><span class="o">(</span><span class="bp">true</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Previously, I always used one of the two following styles (<code>style_1</code> and <code>style_2</code>):</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="n">style_1</span> <span class="n">x</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">du</span> <span class="o">=</span> <span class="n">doSomething</span> <span class="n">x</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">match</span> <span class="n">du</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">A</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">d</span><span class="err">”</span> <span class="n">i</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">B</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">s</span><span class="err">”</span> <span class="n">s</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">C</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">b</span><span class="err">”</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="n">style_2</span> <span class="n">x</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">x</span>
</span><span class='line'>  <span class="o">|&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">doSomething</span>
</span><span class='line'>  <span class="o">|&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">fun</span> <span class="n">a</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">match</span> <span class="n">a</span> <span class="k">with</span>
</span><span class='line'>              <span class="o">|</span> <span class="nc">A</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">d</span><span class="err">”</span> <span class="n">i</span>
</span><span class='line'>              <span class="o">|</span> <span class="nc">B</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">s</span><span class="err">”</span> <span class="n">s</span>
</span><span class='line'>              <span class="o">|</span> <span class="nc">C</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">b</span><span class="err">”</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Both <code>style_1</code> and <code>style_2</code> leave a lot to be desired.  Both <code>style_1</code> and <code>style_2</code> require the use of an intermediate variable and 
<code>style_2</code> needs the clunky <code>fun a -&gt;</code> rigging.  The choice between two types of clunkiness always frustrated me,
because I felt that there must be some easy way to pipe the result of a function into a pattern match.</p>

<p>The pattern matching <code>function</code> makes it possible to elegantly integrate a pattern match into a <code>|&gt;</code> flow.
Here’s my new style implementation of the above code:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">let</span> <span class="n">style_3</span> <span class="n">x</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">x</span>
</span><span class='line'>  <span class="o">|&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">doSomething</span>
</span><span class='line'>  <span class="o">|&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">function</span>
</span><span class='line'>     <span class="o">|</span> <span class="nc">A</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">d</span><span class="err">”</span> <span class="n">i</span>
</span><span class='line'>     <span class="o">|</span> <span class="nc">B</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">s</span><span class="err">”</span> <span class="n">s</span>
</span><span class='line'>     <span class="o">|</span> <span class="nc">C</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">printfn</span> <span class="err">“</span><span class="o">%</span><span class="n">b</span><span class="err">”</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This is no profound revelation or anything, but it’s a tiny step closer to producing truly
elegant F# code.  That makes me supremely happy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zippers 2: Building a Rose Tree Zipper]]></title>
    <link href="http://erichgess.github.io/blog/2015/11/01/zippers-2-building-a-rose-tree-zipper/"/>
    <updated>2015-11-01T09:38:55-05:00</updated>
    <id>http://erichgess.github.io/blog/2015/11/01/zippers-2-building-a-rose-tree-zipper</id>
    <content type="html"><![CDATA[<p>As a follow up to my post about Zippers for lists and binary trees, I wanted to create a zipper for
a slightly more complex data structure.  The Rose Tree is a tree structure where the number of
branches a node may have is variable.  An example of a rose tree would be the directory structure
on your computer:  each directory may contain 0 or more sub directories which, in turn, may contain
addition subdirectories.  With this example in mind, the zipper is analagous to you moving through
your computers file system:  starting at the root directory and using <code>cd</code> to move down a branch
and <code>cd ..</code> to move back.</p>

<!-- more -->

<h2 id="rose-tree-implementation">Rose Tree Implementation</h2>
<p>The implementation of a rose tree is pretty simple.  It’s just like a binary tree but, instead of
each node having two branches, each node has a list of branches:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">RoseTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">RoseTree</span> <span class="k">of</span> <span class="err">‘</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="nc">RoseTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="kt">list</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The zipper of the rose tree, however, is a lot more interesting and fun.  It’s basically a
combination of the binary tree zipper and the list zipper:  you need a tree zipper to keep track
of where in the tree you are by level and a list zipper to keep track of where in the each node’s
list of branches you are.</p>

<p>Algebraicly, the rose tree is:
<script type="math/tex">R = 1 + a\cdot L(R)</script></p>

<p>Where <script type="math/tex">L(R)</script> is a list of rose trees.</p>

<p>The derivative is:</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\begin{eqnarray} 
\partial_aR &=& L(R) + a\partial_aL(R)\partial_aR \\
\partial_aR - a\partial_aL(R)\partial_aR &=& L(R) \\
(1 - a\partial_aL(R))\partial_aR &=& L(R) \\
\partial_aR &=& \frac{L(R)}{1-a\partial_aL(R)} \\
&=& L(R)\frac{1}{1 - a\partial_aL(R)} \\
&=& L(R)L(a\partial_aL(R)) \\
&=& L(R)L(aL^2(R)) \\
\end{eqnarray}
 %]]&gt;</script>

<p>The next to last step uses the identity <script type="math/tex">L(a) = \frac{1}{1 - a}</script> to arrive at <script type="math/tex">L(R)L(aL^2(R))</script>.</p>

<p>This translates to the type:
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">type</span> <span class="nc">RoseTreeZipper</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">=</span> <span class="err">‘</span><span class="n">a</span> <span class="o">*</span> <span class="nc">RoseTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="kt">list</span> <span class="o">*</span> <span class="o">((</span><span class="err">‘</span><span class="n">a</span> <span class="o">*</span> <span class="nc">RoseTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="kt">list</span> <span class="o">*</span> <span class="nc">RoseTree</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="err">’</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="kt">list</span><span class="o">)</span> <span class="kt">list</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
and that looks pretty insane.</p>

<p>However, it does make sense.  Here’s the break down.  The first part <code>'a</code> is the value of the current
node and the <code>RoseTree&lt;'a&gt; list</code> is the list of branches at this node.  So, together
<code>'a * RoseTree&lt;'a&gt; list</code> is the cursors current position in the rose tree.</p>

<p>Now here’s the break down for <code>('a * RoseTree&lt;'a&gt; list * RoseTree&lt;'a&gt; list) list</code>.  This is a list of
the previous positions the cursor had in the rose tree, just like we saw with the binary tree zipper.
The <code>'a</code> is the value of the node the cursor used to point at.  The tuple <code>RoseTree&lt;'a&gt; list * RoseTree&lt;'a&gt; list</code>
is all the branches of the node except where the cursor is currently at!  The first <code>RoseTree&lt;'a&gt; list</code>
is the branches to the left of the branch down which the cursor went and the second <code>RoseTree&lt;'a&gt; list</code>
is all the branches to the right!</p>

<p>To help clarify how the rose tree zipper works, here’s a visual explanation.</p>

<p>The color green indicates the position of the cursor.</p>

<p>Here we are with a newly created zipper on a rose tree.  The cursor is pointing to the root of the tree
<img src="http://erichgess.github.io/assets/zippers/rosetree_1.png" alt="My helpful screenshot" /></p>

<p>We’ll move the cursor down to the middle branch.  The root of the tree and the left and right branches
are then moved into the history list for the cursor.  The color blue is used to show that all those
nodes are grouped together as one entry in the history list.
<img src="http://erichgess.github.io/assets/zippers/rosetree_2.png" alt="Moving the cursor" /></p>

<p>Here’s a visual of the rose tree zipper value after the cursor is moved to the middle node.  The cursor
points to (C, [G; H]), corresponding to the <code>'a * RoseTree&lt;'a&gt; list</code> in the zipper type.  The previous
cursor position corresponds to the list of <code>'a * RoseTree&lt;'a&gt; list * RoseTree&lt;'a&gt; list</code>.
<img src="http://erichgess.github.io/assets/zippers/rosetree_2_note.png" alt="The zipper type" /></p>

<p>Moving the cursor down the left branch, the previous node and the right branch are colored to indicate
that they are grouped together and prepended to the history list.
<img src="http://erichgess.github.io/assets/zippers/rosetree_3.png" alt="Move cursor down left branch" /></p>

<p>Visualizing the new rose tree zipper value.  <code>C, H</code> have been moved to the head of the history list.
<img src="http://erichgess.github.io/assets/zippers/rosetree_3_note.png" alt="New rose tree zipper value" /></p>
]]></content>
  </entry>
  
</feed>
